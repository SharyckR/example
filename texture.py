MY_ARCHIVE = (
    "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"
            )




GENERATE_COMPILED_VERSION = False



#<-------------------------------------------------------------------------->#
#----------------------------------------------------------------------------
# Name:         PyEmbeddedImageManager.py
# Purpose:      Make art repositories easier to maintain and refactor
#             
# Original Author:       Keith Brafford
#                        keith.brafford@gmail.com
#                        Embedded Excellence, Inc.
#
# Version:      1.1
# Date:         4 December 2011
#
# License:      wxWindows license
#
#               Tip: for faster load times, use the compileall module to make
#                    pyc or pyo files after regenerating or exporting new art
#                    modules.  For example, run the following command from
#                    the directory where the modules live:
#
#                    python -O -m compileall ./
#
#----------------------------------------------------------------------------
# 
# 1.4 Release - Keith Brafford
# Date:         12 March 2012
#
# o Fixed bug in named asset retrieval
# 
#----------------------------------------------------------------------------
# 
# 1.3 Release - Keith Brafford
# Date:         11 January 2012
#
# o Changed exported module extension back to .py 
# 
#----------------------------------------------------------------------------
# 
# 1.2 Release - Keith Brafford
# Date:         5 January 2012
#
# o Changed exported module extension to .pyw 
# 
#----------------------------------------------------------------------------
#
# 1.1 Release - Keith Brafford
#
# o Added support for compiled modules
# o Made it clearer when large modules were being processed 
# 
#----------------------------------------------------------------------------
#
# 1.0 Release - Keith Brafford
# Date:         24 November 2011
#
# o Original PyEmbeddedImageManager released
# 
#----------------------------------------------------------------------------

__version__ = "1.2"
__author__  = "Keith Brafford <keith.brafford@gmail.com>"
__date__    = "5 January 2012"

import wx
from wx.lib.embeddedimage import PyEmbeddedImage
import zipfile
import cStringIO
import base64
import os

global ArtManager
ArtManager = None

def GetArtManager():
    global ArtManager
    if ArtManager == None:
        ArtManager = _ArtManager()
    return ArtManager

class _ArtManager(object):
    def __init__(self, archive = MY_ARCHIVE, root=""):
        data = base64.decodestring(archive)
        self.zipfile = None
        self.assetusagelist = set([])
        if archive:
            self.zipfile = zipfile.ZipFile(cStringIO.StringIO(data),"r")
            self.assetusagelist = set(self.GetAssetList())
        self.root = root
        self.imagecache, self.bitmapcache, self.iconcache = {},{},{}
    def SetRoot(self, root):
        self.root = root
    def GetImage(self, filename):
        filename = os.path.join(self.root,filename)
        self.assetusagelist.discard(filename)
        if self.imagecache.has_key(filename):
            return self.imagecache[filename]
        bitmapfile = self.zipfile.open()
        image = wx.ImageFromStream(cStringIO.StringIO(bitmapfile.read()))
        self.imagecache[filename] = image
        return image
    def GetBitmap(self, filename):
        filename = os.path.join(self.root,filename)
        self.assetusagelist.discard(filename)        
        if self.bitmapcache.has_key(filename):
            return self.bitmapcache[filename]    
        bitmapfile = self.zipfile.open(filename)
        image = wx.ImageFromStream(cStringIO.StringIO(bitmapfile.read()))
        bitmap = image.ConvertToBitmap()
        self.bitmapcache[filename] = bitmap
        return bitmap
    def GetIcon(self, filename):
        filename = os.path.join(self.root,filename)
        self.assetusagelist.discard(filename)        
        if self.iconcache.has_key(filename):
            return self.iconcache[filename]
        bitmapfile = self.zipfile.open(filename)
        pei =  PyEmbeddedImage(bitmapfile.read(), isBase64 = False)
        icon = pei.GetIcon()
        self.iconcache[filename] = icon
        return icon
    def GetAssetList(self):
        if self.zipfile:
            return self.zipfile.namelist()
        else:
            return []
    def GetNamedContents(self, name):
        filename = os.path.join(self.root,name)
        self.assetusagelist.discard(filename)
        fp = self.zipfile.open(filename)
        return fp.read()
    def GetLicense(self):        
        return self.GetNamedContents("License.txt")
    def GetUnusedAssetList(self):
        return self.assetusagelist

if __name__ == "__main__":
    import tempfile        
    import textwrap
    import shutil
    import sys
    import py_compile

    class InMemoryZip(object):
        def __init__(self):
            # Create the in-memory file-like object
            self.in_memory_zip = cStringIO.StringIO()

        def append(self, filename_in_zip, file_contents):
            '''Appends a file with name filename_in_zip and contents of
               file_contents to the in-memory zip.'''
            # Get a handle to the in-memory zip in append mode
            zf = zipfile.ZipFile(self.in_memory_zip, "a", zipfile.ZIP_DEFLATED, False)
            # Write the file to the in-memory zip
            zf.writestr(filename_in_zip, file_contents)      
            # Mark the files as having been created on Windows so that
            # Unix permissions are not inferred as 0000
            for zfile in zf.filelist:
                zfile.create_system = 0      
            return self
        def read(self):
            '''Returns a string with the contents of the in-memory zip.'''
            self.in_memory_zip.seek(0)
            return self.in_memory_zip.read()

    def ExtractArchive(zf):
        """Extracts zip archive to temp folder"""
        tempdir = tempfile.mkdtemp()
        if zf:
            zf.extractall(tempdir)
        return tempdir

    def DeleteTempFiles(tempdir):        
        try:
            shutil.rmtree(tempdir)
            return True
        except:
            return False

    def BundleArchive(tempdir):
        global GENERATE_COMPILED_VERSION                
        zipfiledata = ""
        imz = InMemoryZip()    
        rootlen = len(tempdir)                 
        if tempdir != None:
            for root, dirs, files in os.walk(tempdir):
                basedir = root[rootlen:]
                for filename in files:
                    if not filename.startswith("."):
                        with open(os.path.join(root,filename),"rb") as f:
                            contents = f.read()
                        zipfilename = os.path.join(basedir, filename)
                        imz.append(zipfilename,contents)
            zipfiledata = imz.read()
        b64data = base64.encodestring(zipfiledata)
        b64lines = textwrap.wrap(b64data, 80)
        b64lines = ['    "%s"\n' % line for line in b64lines]  
        if len(b64lines) > 0:
            new_archive = ["MY_ARCHIVE = (\n"]
            new_archive.extend(b64lines)
            new_archive.append("            )\n\n\n\n\n")
        else:
            new_archive = ['MY_ARCHIVE = ""\n\n\n\n\n']
        new_archive.append("GENERATE_COMPILED_VERSION = %s\n\n\n\n" % str(GENERATE_COMPILED_VERSION))
        return new_archive

    def ProcessModule(new_archive, filename, template):
        global GENERATE_COMPILED_VERSION
        with open(template, "rb") as f:
            while True:
                line = f.readline()
                if line.startswith("#<---"):
                    keeper = [line]
                    keeper.extend(f.readlines())
                    break
        if not filename.endswith(".py"): filename += ".py"
        f = open(filename, "wb")
        f.writelines(new_archive)
        f.writelines(keeper)
        f.close()
        if GENERATE_COMPILED_VERSION:
            print "Doing compiled version"
            py_compile.compile(filename)

    class MyDialog(wx.Dialog):
        def __init__(self, parent, id = -1, artman = None):
            if artman == None:
                wx.MessageBox("No Art Manager specified", "Error", wx.OK)
                self.EndModal(-1)
                return
            title = "Art Manager - %s" % sys.argv[0]
            wx.Dialog.__init__(self, parent,id, title, pos = (5,5), style = wx.DEFAULT_DIALOG_STYLE)
            self.artman = artman
            self.button_delete = wx.Button(self, -1, "Delete Temp Files (No Reencode)")
            self.button_explore = wx.Button(self, -1, "Extract and Explore")
            self.button_encode = wx.Button(self, -1, "Encode And Repack")
            self.button_export = wx.Button(self, -1, "Export New Module")
#            self.checkbox_provider = wx.CheckBox(self, -1, "Include ArtProvider?")
            self.static_line = wx.StaticLine(self, -1, style = wx.LI_VERTICAL)
            self.static_line2 = wx.StaticLine(self, -1, style = wx.LI_VERTICAL)

            self.checkbox_compile = wx.CheckBox(self, -1, "Generate .pyc(o)", style = wx.ALIGN_RIGHT)
            
            self.buttonsizer = wx.BoxSizer(wx.HORIZONTAL)
            self.buttonsizer.AddStretchSpacer()            
            self.buttonsizer.Add(self.button_explore, 0, wx.ALIGN_CENTRE_VERTICAL | wx.LEFT, 5)
            self.buttonsizer.AddSpacer(20)
            self.buttonsizer.Add(self.static_line, 0, wx.EXPAND | wx.ALL, 5)
            self.buttonsizer.AddSpacer(20)            
#            self.buttonsizer.Add(self.checkbox_provider, 0, wx.ALIGN_CENTRE_VERTICAL |wx.LEFT | wx.RIGHT, 5)

            self.middlesizer = wx.BoxSizer(wx.VERTICAL)
            self.middletopsizer = wx.BoxSizer(wx.HORIZONTAL)
            self.middletopsizer.Add(self.button_encode, 0, wx.ALIGN_CENTRE_VERTICAL | wx.RIGHT,  10)
            self.middletopsizer.Add(self.button_export, 0, wx.ALIGN_CENTRE_VERTICAL | wx.LEFT, 10)
            self.middlebottomsizer = wx.BoxSizer(wx.HORIZONTAL)
            self.middlebottomsizer.AddStretchSpacer()
            self.middlebottomsizer.Add(self.checkbox_compile, 0, wx.RIGHT, 25)
            self.middlebottomsizer.AddStretchSpacer()       
            self.middlesizer.Add(self.middletopsizer,0)
            self.middlesizer.Add(self.middlebottomsizer,0, wx.BOTTOM | wx.TOP | wx.EXPAND, 5)

            self.buttonsizer.Add(self.middlesizer, 0)
                                         
            self.buttonsizer.AddSpacer(20)
            self.buttonsizer.Add(self.static_line2, 0, wx.EXPAND | wx.ALL, 5)
            self.buttonsizer.AddSpacer(20)

            self.buttonsizer.Add(self.button_delete,0, wx.ALIGN_CENTRE_VERTICAL | wx.RIGHT, 5)
            self.buttonsizer.AddStretchSpacer()

#            self.app = ArtProviderPanel(self)

            self.mainsizer = wx.BoxSizer(wx.VERTICAL)
            self.mainsizer.Add(self.buttonsizer,0, wx.EXPAND | wx.TOP, 2)

            
#            self.mainsizer.Add(self.app, 0, wx.EXPAND)

            self.button_explore.Bind(wx.EVT_BUTTON, self.OnExplore)            
            self.button_encode.Bind(wx.EVT_BUTTON, self.OnEncode)
            self.button_export.Bind(wx.EVT_BUTTON, self.OnExport)            
            self.button_delete.Bind(wx.EVT_BUTTON, self.OnDelete)
#            self.checkbox_provider.Bind(wx.EVT_CHECKBOX, self.OnCheckBox)

#            self.checkbox_provider.Enable(False)
            self.button_encode.Enable(False)
            self.button_delete.Enable(False)
            self.button_export.Enable(False)            
            self.checkbox_compile.Enable(False)
            
            self.Bind(wx.EVT_CLOSE, self.OnClose)

#            self.app.Hide()
            self.SetSizer(self.mainsizer)            
            self.width, h = self.mainsizer.CalcMin()
            w,h = self.mainsizer.CalcMin()
            self.SetSize((self.width, h+30))
            self.checkbox_compile.SetValue(GENERATE_COMPILED_VERSION)
            
#        def OnCheckBox(self, event):
#            if self.checkbox_provider.GetValue():               
#                self.app.Show(True)
#            else:
#                self.app.Show(False)
#            w,h = self.mainsizer.CalcMin()
#            self.SetSize((self.width, h+30))
#            self.Update()

        def OnClose(self, event):
            self.Destroy()

        def OnDelete(self, event):
            self.button_delete.Enable(False)
            self.button_encode.Enable(False)
            wx.CallAfter(self.PerformDelete)

        def PerformDelete(self):
            while DeleteTempFiles(self.tempdir) == False:
                wx.MessageBox("Can not delete the temp files.  You may need to close the app","Error", wx.OK)
            self.Close()

        def OnExport(self, event):
            global GENERATE_COMPILED_VERSION
            import os
            dlg = wx.FileDialog(self, "Export New Module", os.getcwd(), "", "*.py", wx.FD_SAVE)
            if dlg.ShowModal() == wx.ID_OK:
                GENERATE_COMPILED_VERSION = self.checkbox_compile.GetValue()                
                new_archive = BundleArchive(self.tempdir)
                filename = dlg.GetPath()
                ourfile = sys.argv[0]
                self.button_delete.Enable(False)
                self.button_encode.Enable(False)
                self.checkbox_compile.Enable(False)                        
                ProcessModule(new_archive, filename, ourfile)
                self.PerformDelete()

        def OnEncode(self, event):
            global GENERATE_COMPILED_VERSION
            self.button_delete.Enable(False)
            self.button_encode.Enable(False)
            GENERATE_COMPILED_VERSION = self.checkbox_compile.GetValue()            
            self.checkbox_compile.Enable(False)                        
            wx.BeginBusyCursor()            
            wx.CallAfter(self.PerformEncode)

        def PerformEncode(self):
            new_archive = BundleArchive(self.tempdir)
            ProcessModule(new_archive, __file__, __file__)
            if DeleteTempFiles(self.tempdir) == False:
                wx.MessageBox("Can not delete the temp files.  You may need to close the app","Error", wx.OK)
            self.Close()

        def OnExplore(self, event):
            self.button_explore.Enable(False)
            if os.path.split(sys.argv[0])[1] not in ("PyEmbeddedImageManager.py", "PyEmbeddedImageManager.pyw"):            
                self.button_encode.Enable(True)
            self.button_delete.Enable(True)
            self.button_export.Enable(True)
            self.checkbox_compile.Enable(True)
            
#            self.checkbox_provider.Enable(True)            
            wx.CallAfter(self.PerformExtract)

        def PerformExtract(self):
            try:
                self.tempdir = ExtractArchive(self.artman.zipfile)
            except:
                wx.MessageBox("Extraction Failed.","Error", wx.OK)
                raise

            if sys.platform == "win32":
                exe = "explorer.exe"
            elif sys.platform == "darwin":
                exe = "open"
            elif sys.platform == "linux2":
                exe = "gnome-open"
            else:
                raise NotImplementedError("Not implemented for %s" % sys.platform)

            import subprocess
            subprocess.call([exe, "%s" % self.tempdir])


    a = wx.PySimpleApp()

    artman = GetArtManager()
    dlg = MyDialog(None, artman = artman)

    dlg.ShowModal()
    a.MainLoop()